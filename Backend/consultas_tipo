# Este archivo utiliza los siguientes patrones de diseño de manera implícita:
#
# 1) Patrón Facade (Fachada)
#    El Blueprint "consultas" actúa como una fachada que centraliza todas las
#    operaciones del sistema (profesores, equipos, préstamos y devoluciones).
#    Gracias a esto, el frontend u otros módulos solo interactúan con una capa
#    sencilla de rutas sin conocer la lógica interna ni el acceso a la base de datos.
#
# 2) Patrón Strategy (Estrategia)
#    Antes de ejecutar cada operación importante, se elige una función de validación
#    distinta según el caso: validar_profesor, validar_equipo, validar_prestamo,
#    validar_detalle_prestamo, validar_devolucion, validar_eliminar_prestamo.
#    Cada función representa una estrategia de validación independiente y
#    especializada para cada tipo de operación.
#
# 3) Patrón Singleton (utilizado indirectamente)
#    La función get_db() —proveniente del módulo database— suele implementarse como
#    Singleton para que haya una única conexión por request. Este archivo depende
#    de ese patrón aunque no lo implementa directamente.
#
# 4) Patrón Transaction Script
#    Cada ruta maneja toda la lógica necesaria de una operación (consultas, inserts,
#    updates, validaciones y transacciones). Este estilo organiza cada acción de
#    negocio como un "script" secuencial y atómico, especialmente visible en:
#    - agregar_equipo_a_prestamo()
#    - devolver_equipo()
#    donde se manejan commits, rollbacks y pasos agrupados.
#
# Estos patrones combinados permiten que el código sea modular, validado,
# seguro en transacciones y fácil de mantener.

#--------------------------------------------------



# Se utiliza un único Blueprint principal para todas las rutas
consultas_bp = Blueprint("consultas", __name__) 

# RUTAS PARA PROFESORES (CRUD)

# GET - obtener todos los profesores
@consultas_bp.get("/profesores")
def obtener_profesores():
    db = get_db()
    cursor = db.cursor(dictionary=True) # Usamos dictionary=True para obtener resultados como dicts

    cursor.execute("SELECT * FROM Profesor")
    profesores = cursor.fetchall()

    cursor.close()
    return jsonify(profesores)


# POST - crear profesor
@consultas_bp.post("/profesores")
def crear_profesor():
    data = request.json
    # Usamos la nueva función de validación (asumimos que existe y fue creada)
    error = validar_profesor(data)

    if error:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor()

    sql = "INSERT INTO Profesor (nombre, apellido, email) VALUES (%s, %s, %s)"
    valores = (data["nombre"], data["apellido"], data["email"])

    try:
        cursor.execute(sql, valores)
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error de BD al crear profesor: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Profesor creado correctamente"}), 201

# PUT - actualizar profesor
@consultas_bp.put("/profesores/<int:id_profesor>")
def editar_profesor(id_profesor):
    data = request.json
    error = validar_profesor(data) # Se asume que validar_profesor puede usarse para PUT

    if error:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor()

    sql = """
        UPDATE Profesor 
        SET nombre=%s, apellido=%s, email=%s
        WHERE id_Profesor=%s
    """

    valores = (data["nombre"], data["apellido"], data["email"], id_profesor)

    try:
        cursor.execute(sql, valores)
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error de BD al actualizar profesor: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Profesor actualizado correctamente"})


# DELETE - eliminar profesor
@consultas_bp.delete("/profesores/<int:id_profesor>")
def eliminar_profesor(id_profesor):
    db = get_db()
    cursor = db.cursor()

    # Nota: Se debe tener cuidado con FKs aquí. Si tiene préstamos, fallará.
    sql = "DELETE FROM Profesor WHERE id_Profesor=%s"
    
    try:
        cursor.execute(sql, (id_profesor,))
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error: No se puede eliminar el profesor (posiblemente tiene préstamos asociados)"}), 400
    finally:
        cursor.close()

    return jsonify({"mensaje": "Profesor eliminado"})

# RUTAS PARA EQUIPOS (CRUD)

# GET - obtener equipos
@consultas_bp.get("/equipos")
def obtener_equipos():
    db = get_db()
    cursor = db.cursor(dictionary=True)

    cursor.execute("SELECT * FROM Equipo")
    equipos = cursor.fetchall()

    cursor.close()
    return jsonify(equipos)

# POST - crear equipo
@consultas_bp.post("/equipos")
def crear_equipo():
    data = request.json
    # Usamos la nueva función de validación (asumimos que existe y fue creada)
    error = validar_equipo(data)

    if error:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor()
    sql = "INSERT INTO Equipo (nombre, serie, stock) VALUES (%s, %s, %s)"
    valores = (data["nombre"], data["serie"], data["stock"])

    try:
        cursor.execute(sql, valores)
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error de BD al registrar equipo: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Equipo registrado correctamente"}), 201

# 

# PUT - actualizar equipo
@consultas_bp.put("/equipos/<int:id_equipo>")
def editar_equipo(id_equipo):
    data = request.json
    error = validar_equipo(data) 

    if error:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor()

    sql = """
        UPDATE Equipo 
        SET nombre=%s, serie=%s, stock=%s
        WHERE id_Equipo=%s
    """

    valores = (data["nombre"], data["serie"], data["stock"], id_equipo)

    try:
        cursor.execute(sql, valores)
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error de BD al actualizar equipo: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Equipo actualizado correctamente"})

# DELETE - borrar equipo
@consultas_bp.delete("/equipos/<int:id_equipo>")
def eliminar_equipo(id_equipo):
    db = get_db()
    cursor = db.cursor()

    sql = "DELETE FROM Equipo WHERE id_Equipo=%s"

    try:
        cursor.execute(sql, (id_equipo,))
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": "Error: No se puede eliminar el equipo (posiblemente tiene préstamos asociados)"}), 400
    finally:
        cursor.close()

    return jsonify({"mensaje": "Equipo eliminado"})

# RUTAS PARA PRÉSTAMOS (Encabezado y Detalle) - Lógica de Negocio
# GET - obtener todos los préstamos (Encabezados + Detalles)
@consultas_bp.get("/prestamos")
def obtener_prestamos():
    db = get_db()
    cursor = db.cursor(dictionary=True)
    
    # Se recomienda hacer un JOIN para obtener un resumen completo de cada préstamo
    sql = """
    SELECT 
        p.id_Prestamo, p.fk_id_Profesor, p.fecha_solicitud, p.estado AS estado_prestamo,
        dp.id_Detalle_prestamo, dp.fk_id_equipo, dp.fecha_entrega, dp.estado AS estado_detalle
    FROM Prestamo p
    JOIN Detalle_prestamo dp ON p.id_Prestamo = dp.fk_id_Prestamo
    ORDER BY p.id_Prestamo DESC, dp.id_Detalle_prestamo
    """
    cursor.execute(sql)
    return jsonify(cursor.fetchall())


# POST - Crear Encabezado de Préstamo (solo la solicitud)
@consultas_bp.post("/prestamos")
def crear_encabezado_prestamo():
    data = request.json
    
    error = validar_prestamo(data) # Valida existencia del profesor
    if error is not True:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor()

    # Solo insertamos el ID del profesor, fecha_solicitud y estado inicial
    sql = """
        INSERT INTO Prestamo(fk_id_Profesor, fecha_solicitud, estado)
        VALUES (%s, NOW(), 'Solicitado')
    """
    valores = (data["fk_id_Profesor"],)

    try:
        cursor.execute(sql, valores)
        id_prestamo = cursor.lastrowid # Obtener el ID recién creado
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error al crear encabezado de préstamo: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Encabezado de Préstamo creado con éxito", "id_Prestamo": id_prestamo}), 201


# POST - Agregar Equipo a un Préstamo Existente (Detalle_prestamo)
@consultas_bp.post("/detalle-prestamos")
def agregar_equipo_a_prestamo():
    data = request.json

    # Valida existencia de Préstamo, Equipo, y lo más importante: 
    # que el equipo NO esté ya en estado 'Prestado'.
    error = validar_detalle_prestamo(data)
    if error is not True:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor()
    
    id_equipo = data["fk_id_equipo"]

    # 1. Insertar el Detalle_prestamo (marcándolo como 'Prestado')
    sql_detalle = """
        INSERT INTO Detalle_prestamo(fk_id_equipo, fk_id_Prestamo, fecha_entrega, estado)
        VALUES (%s, %s, NOW(), 'Prestado')
    """
    valores_detalle = (id_equipo, data["fk_id_Prestamo"])

    # 2. Actualizar el stock/estado global del Equipo
    sql_equipo = "UPDATE Equipo SET stock = stock - 1 WHERE id_Equipo=%s"

    try:
        # INICIO DE TRANSACCIÓN ATÓMICA
        cursor.execute(sql_detalle, valores_detalle)
        cursor.execute(sql_equipo, (id_equipo,))
        db.commit() # Si ambos son exitosos, se guarda
    except Exception as e:
        db.rollback() # Si algo falla, se revierte todo
        return jsonify({"error": f"Error en la transacción de agregar equipo: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Equipo agregado al préstamo y marcado como prestado con éxito"})


# PUT - Marcar Devolución de un Equipo Específico (Detalle_prestamo)
@consultas_bp.put("/devoluciones/<int:id_detalle>")
def devolver_equipo(id_detalle):
    
    # 1. Validar si el detalle existe y no está ya devuelto
    error = validar_devolucion(id_detalle)
    if error is not True:
        return jsonify({"error": error}), 400

    db = get_db()
    cursor = db.cursor(dictionary=True)

    try:
        # INICIO DE TRANSACCIÓN ATÓMICA
        
        # 2. Obtener el ID del equipo antes de actualizar
        cursor.execute("SELECT fk_id_equipo FROM Detalle_prestamo WHERE id_Detalle_prestamo = %s", (id_detalle,))
        detalle_info = cursor.fetchone()
        if not detalle_info:
             # Debería ser atrapado por la validación, pero como doble chequeo
            return jsonify({"error": "Detalle de préstamo no encontrado."}), 404
        
        id_equipo = detalle_info["fk_id_equipo"]
        
        # 3. Actualizar el Detalle_prestamo a 'Devuelto' con fecha de hoy
        sql_detalle = """
            UPDATE Detalle_prestamo 
            SET fecha_devolucion = NOW(), estado = 'Devuelto'
            WHERE id_Detalle_prestamo=%s
        """
        cursor.execute(sql_detalle, (id_detalle,))
        
        # 4. Actualizar stock del Equipo (stock = stock + 1)
        sql_equipo = "UPDATE Equipo SET stock = stock + 1 WHERE id_Equipo=%s"
        cursor.execute(sql_equipo, (id_equipo,))
        
        db.commit() # Si ambos son exitosos, se guarda
    except Exception as e:
        db.rollback() # Si algo falla, se revierte todo
        return jsonify({"error": f"Error en la transacción de devolución: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Devolución registrada correctamente"})

# DELETE — eliminar registro de préstamo (Encabezado)
@consultas_bp.delete("/prestamos/<int:id_prestamo>")
def borrar_prestamo(id_prestamo):
    # 1. Validar que no tenga detalles asociados (equipos prestados)
    error = validar_eliminar_prestamo(id_prestamo)
    if error is not True:
        return jsonify({"error": error}), 400
        
    db = get_db()
    cursor = db.cursor()

    sql = "DELETE FROM Prestamo WHERE id_Prestamo = %s"

    try:
        cursor.execute(sql, (id_prestamo,))
        db.commit()
    except Exception as e:
        db.rollback()
        return jsonify({"error": f"Error de BD al eliminar préstamo: {e}"}), 500
    finally:
        cursor.close()

    return jsonify({"mensaje": "Encabezado de Préstamo eliminado"}), 200